# 是什么
动态规划算法是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决

>关键字：分治、重叠子问题、状态转移

# 解释
* 重叠子问题  
对问题进行分而治之递归思考之后，发现拆分的子问题有大量重复的，称之为重叠子问题
* 状态转移  
是动态规划中本阶段的状态往往是上一阶段状态和上一阶段决策的结果。比如经典动态规划问题--斐波那契数列，其状态转移方程为 f(n) = f(n-1) + f(n-2); 所谓的状态转移方程，可以理解为：如何通过已知状态(上一阶段决策的结果)来求得未知状态(本阶段)的决策结果

# 理解
>斐波那契数列

1. 首先递归拆分问题  
想求解f(n)的值，则需要知道f(n-1)和f(n-2)的结果；  
想求解f(n-1)的结果，则需要知道f(n-2)和f(n-3)的结果；  
想求解f(n-2)的结果，则需要知道f(n-3)和f(n-4)的结果....  
此时便发现有多个重复计算的子问题，如此处的f(n-2)、f(n-3)等
2. 寻找状态转移过程  
自底向上记录决策结果，如初始条件为f(1) = 1, f(2) = 1;
```
for(int i = 2 ; i < arr.length; i++){
    arr[i] = arr[i-1] + arr[i-2];
}
其中arr[0] = 1; arr[1] = 1
```
利用数组记录下每个阶段的决策结果，用于下一阶段决策使用

>背包问题
* 描述  
给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。假设有n件物品，依次的价格为v1、v2、v3。。。。vn，重量依次为m1、m2、m3。。。。mn，背包总共可以容纳重量为M，求如何组合物品到背包中，可以使得价值最大

1. 递归分析  
想求解背包容量为M的结果，则需要知道M-1、M-2、M-3......1的结果；  
想求解背包容量为M-1的结果，则需要知道M-2、M-3...1的结果....
以此类推，求大背包问题，可以看作是求若干个小背包的问题
2. 寻找状态转移过程
这里涉及到多个维度的子问题==>背包可以拆分为小背包、物件选择范围可以拆分为更小的选择范围，可以构造为一个二维数组
假设此时有4个物品、背包容量为5，物品重量为[1,2,2,3],价值为[1,3,2,4],假设列代表背包重量，行代表物品选择范围
```
初始状态(其中第一行和第一列填充0，表示占位)
开始填第一行，此时由于只有一个物品选择，所有第一行价值全部是1
      1   2   3   4   5
|-----------------------|
| 0 | 0 | 0 | 0 | 0 | 0 |
|-----------------------|
| 0 | 1 | 1 | 1 | 1 | 1 |
|-----------------------|
| 0 | 0 | 0 | 0 | 0 | 0 |
|-----------------------|
| 0 | 0 | 0 | 0 | 0 | 0 |
|-----------------------|
| 0 | 0 | 0 | 0 | 0 | 0 |
|-----------------------|

开始决策有两个物品可以选择的情况(填第二行)
步骤：
判断当前是否有足够的空间选择第二件物品，如果不够，则直接使用从上一行求出的结果填入，如果够，则可以对比选择该物品和不选择该物品的情况，哪个价值更高，并将高价值的决策填入网格

      1   2   3   4   5
|-----------------------|
| 0 | 0 | 0 | 0 | 0 | 0 |
|-----------------------|
| 0 | 1 | 1 | 1 | 1 | 1 |
|-----------------------|
| 0 | 1 | 3 | 4 | 4 | 4 |
|-----------------------|
| 0 | 0 | 0 | 0 | 0 | 0 |
|-----------------------|
| 0 | 0 | 0 | 0 | 0 | 0 |
|-----------------------|

。。。。以此类推，最后的网格如下
      1   2   3   4   5
|-----------------------|
| 0 | 0 | 0 | 0 | 0 | 0 |
|-----------------------|
| 0 | 1 | 1 | 1 | 1 | 1 |
|-----------------------|
| 0 | 1 | 3 | 4 | 4 | 4 |
|-----------------------|
| 0 | 1 | 3 | 4 | 5 | 6 |
|-----------------------|
| 0 | 1 | 3 | 4 | 5 | 6 |
|-----------------------|

可知最大价值可以到6
组合为 物品 n1、n2、n3

可以将上述过程表达为这样的状态转移方程(上述案例假设k为1,即背包递增按1来递增):

f[i][v]=max{ f[i-1][v-k*c[i]]+k*w[i] , k*c[i] }
```

>经典例题——最长公共子序列和最长公共子串
+ 描述  
例如两个字符串A="HelloWorld"和B="loop",则A和B的最长公共子序列为"loo"(最长公共子序列不需要相邻，只需要序列);最长公共子串为"lo"

+ 思路  
一般打算采用Dp解决的问题，可以先进行一次递归思考，找到重叠子问题后，再找状态转移方程。

+ LCS(最长公共子序列)最有子结构
令 X=|x[1],x[2],...,x[i]| 和 Y=|y[1],y[2],...,y[j]|为两个序列，Z=|z[1],z[2],z[3],...,z[k]|为X和Y的LCS。则
>+ 如果 x[i] = y[j], 则z[k] = x[i] = y[j] ,说明 Z = |z[1],z[2],...,z[k-1]| 是 X = |x[1],x[2],....,x[i-1]| 和 Y = |y[1],y[2],...,y[j-1]| 的 LCS  
>+ 如果 x[i] != y[j], 如果z[k] != x[i],说明Z=|z[1],z[2],...,z[k]| 是 X = |x[1],x[2],....,x[i-1]| 和 Y = |y[1],y[2],...,y[j]| 的LCS
>+ 如果 x[i] != y[j], 如果z[k] != y[i],说明Z=|z[1],z[2],...,z[k]| 是 X = |x[1],x[2],....,x[i]| 和 Y = |y[1],y[2],...,y[j-1]| 的LCS

从上述结论中可以看出，LCS问题具有子问题重叠的性质，根据递归分析，可以自底向上定义出状态转移方程,假设res[i][j]表示LCS长度，则x[i] = y[j]时,res[i][j] = res[i-1][j-1] + 1; 若x[i] != y[j]时,res[i][j] = max {res[i-1][j],res[i][j]}
