# 是什么
动态规划算法是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决

>关键字：分治、重叠子问题、状态转移

# 理解
动态规划 (Dynamic Programic) 是计算机科学领域的一个概念，它是一种特殊的分治思想，利用它可以实现时间复杂度的优化。

Dynamic 动态，即会变化的；

Programming 应理解为「表格法」。

合起来动态规划就是用一张可变的表格来存储运算结果。利用分治和贪心思想来实现的一种算法
利用分治递归思考问题，利用贪心来寻找最优局部解，最终由所有最优局部解来得到最终解

# 举例 
>斐波那契数列

+ 首先递归拆分问题  
想求解f(n)的值，则需要知道f(n-1)和f(n-2)的结果；  
想求解f(n-1)的结果，则需要知道f(n-2)和f(n-3)的结果；  
想求解f(n-2)的结果，则需要知道f(n-3)和f(n-4)的结果....  
此时便发现有多个重复计算的子问题，如此处的f(n-2)、f(n-3)等
+ 状态定义和初始化
此问题可考虑的维度只有n，可以用一个一维数组来存储状态值，定义数组dp[n]用来记录所有状态,对于n=1和n=2给予初始值dp[0] = 1、dp[1] = 1  
+ 寻找状态转移过程  
如下代码
```
for(int i = 2 ; i < dp.length; i++){
    dp[i] = dp[i-1] + dp[i-2];
}
其中dp[0] = 1; dp[1] = 1
```
利用数组记录下每个阶段的决策结果，用于下一阶段决策使用

>背包问题
* 描述  
给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。假设有n件物品，依次的价格为v1、v2、v3。。。。vn，重量依次为m1、m2、m3。。。。mn，背包总共可以容纳重量为M，求如何组合物品到背包中，可以使得价值最大

+ 递归分析  
想求解背包容量为M的结果，则需要知道M-1、M-2、M-3......1的结果；  
想求解背包容量为M-1的结果，则需要知道M-2、M-3...1的结果....
以此类推，求大背包问题，可以看作是求若干个小背包的问题
+ 状态定义和初始化
这里的子问题涉及到两个维度,即：**背包的容量**、**物件选择范围**，可以构造为一个二维数组dp[i][j]来表示当背包容量为i、在|0~j|号物件中选择物品的最优解。那么接下来的问题就是**找到状态转移过程**了，即：**如何通过更小的i和j来得到最终需要的最优解**(想像在一个大背包中，放入更小的小背包来达到价值最大)
+ 寻找状态转移过程
假设此时有4个物品、背包容量为5，物品重量为[1,2,2,3],价值为[1,3,2,4],假设列代表背包重量，行代表物品选择范围
```
初始状态(其中第一行和第一列填充0，表示占位)
开始填第一行，此时由于只有一个物品选择，所有第一行价值全部是1
      1   2   3   4   5
|-----------------------|
| 0 | 0 | 0 | 0 | 0 | 0 |
|-----------------------|
| 0 | 1 | 1 | 1 | 1 | 1 |
|-----------------------|
| 0 | 0 | 0 | 0 | 0 | 0 |
|-----------------------|
| 0 | 0 | 0 | 0 | 0 | 0 |
|-----------------------|
| 0 | 0 | 0 | 0 | 0 | 0 |
|-----------------------|

开始决策有两个物品可以选择的情况(填第二行)
步骤：
判断当前是否有足够的空间选择第二件物品，如果不够，则直接使用从上一行求出的结果填入，如果够，则可以对比选择该物品和不选择该物品的情况，哪个价值更高，并将高价值的决策填入网格

      1   2   3   4   5
|-----------------------|
| 0 | 0 | 0 | 0 | 0 | 0 |
|-----------------------|
| 0 | 1 | 1 | 1 | 1 | 1 |
|-----------------------|
| 0 | 1 | 3 | 4 | 4 | 4 |
|-----------------------|
| 0 | 0 | 0 | 0 | 0 | 0 |
|-----------------------|
| 0 | 0 | 0 | 0 | 0 | 0 |
|-----------------------|

。。。。以此类推，最后的网格如下
      1   2   3   4   5
|-----------------------|
| 0 | 0 | 0 | 0 | 0 | 0 |
|-----------------------|
| 0 | 1 | 1 | 1 | 1 | 1 |
|-----------------------|
| 0 | 1 | 3 | 4 | 4 | 4 |
|-----------------------|
| 0 | 1 | 3 | 4 | 5 | 6 |
|-----------------------|
| 0 | 1 | 3 | 4 | 5 | 6 |
|-----------------------|

可知最大价值可以到6
组合为 物品 n1、n2、n3

可以将上述过程表达为这样的状态转移方程(上述案例假设k为1,即背包递增按1来递增):

dp[i][j]=max{ dp[i-1][v-k*c[i]]+k*w[i] , k*c[i] }
```

>经典例题——最长公共子序列和最长公共子串
+ 描述  
例如两个字符串A="HelloWorld"和B="loop",则A和B的最长公共子序列为"loo"(最长公共子序列不需要相邻，只需要序列);最长公共子串为"lo"

+ 递归分析  
以最长公共子串为例，可以将长度分别为i、j的两个字符串求公子串拆分为两个更短的字符串求出公共子串的问题，显然是有重叠子问题的(不停递归分治长的字符串，多多少少会截取出相同的短字符串的情况)

+ 状态定义  
假设对比字符串长度A、B的长度分别为len1,len2。可以定义一个二维数组dp[i][j]用来记录**字符串A截取到i处的子串和字符串B截取到j处的子串最长公子串长度**，接下来就只剩下如何利用子问题的解来推导出最终解(状态转移)

+ 状态转移过程  
初始化情况：当i、j任意一个为0时，其最长公子串长度均为0,即dp[0][j]和dp[i][0]均为0
根据最长公共子串的定义需要注意：**最后一个元素必须要相等，才能作为当前子问题的最优解**(因为公共子串的要求必须相邻，中间任何一环断掉都不能作为下一个问题的解来使用)，那么此时最长公共子串长度的就是dp[][]中的最大值。  
以字符串A="HelloWorld"和B="loop"为例，参考上面的背包问题表格分析过程得到最终的决策(和背包问题分析过程类似，这里就不再重复详细过程了)
最终得到的表格如下：
```
     h   e   l   l   o   w   o   r   l   d
   |---------------------------------------|
 l | 0 | 0 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 |
   |---------------------------------------|
 o | 0 | 0 | 0 | 0 | 2 | 0 | 0 | 0 | 0 | 0 |
   |---------------------------------------|
 o | 0 | 0 | 0 | 0 | 1 | 0 | 1 | 0 | 0 | 0 |
   |---------------------------------------|
 p | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
   |---------------------------------------|
```
